{"version":3,"sources":["auth/auth.strategy.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,2CAA2E;AAC3E,+CAAoD;AACpD,+CAAoD;AACpD,iDAA6C;AAS7C,IAAa,WAAW,GAAxB,iBAAyB,SAAQ,2BAAgB,CAAC,uBAAQ,CAAC;IAEzD,YAAkD,WAAwB;QAExE,KAAK,CAAC;YAEJ,cAAc,EAAE,yBAAU,CAAC,2BAA2B,EAAE;YACxD,WAAW,EAAE,WAAW,CAAC,SAAS;YAIlC,gBAAgB,EAAE,KAAK;YACvB,iBAAiB,EAAE,KAAK;SACzB,CAAC,CAAC;QAX6C,gBAAW,GAAX,WAAW,CAAa;IAY1E,CAAC;IAmBK,QAAQ,CAAC,OAAa,EAAE,IAAc;;YAE1C,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;YAE1D,IAAI,CAAC,IAAI,EAAE;gBACT,OAAO,IAAI,CAAC,IAAI,8BAAqB,EAAE,EAAE,KAAK,CAAC,CAAC;aACjD;YAED,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QACxB,CAAC;KAAA;CACF,CAAA;AA3CY,WAAW;IADvB,mBAAU,EAAE;IAGE,WAAA,eAAM,CAAC,0BAAW,CAAC,CAAA;qCAA+B,0BAAW;GAF/D,WAAW,CA2CvB;AA3CY,kCAAW","file":"auth.strategy.js","sourcesContent":["import { Injectable, UnauthorizedException, Inject } from \"@nestjs/common\";\nimport { ExtractJwt, Strategy } from \"passport-jwt\";\nimport { PassportStrategy } from \"@nestjs/passport\";\nimport { AuthService } from \"./auth.service\";\nimport { User } from \"../model/user.entity\";\n\n/*\n认证策略，这里使用的是jsonwebtoken\nJwtStrategy继承了PassportStrategy(Strategy)类，这个类构造函数中，保证passport采用这个策略\n并且将参数赋值给JwtStrategy实例，第一个参数是选项，第二个参数是validate方法\n */\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n\n  constructor(@Inject(AuthService) private readonly authService: AuthService) {\n    /* 调用父类构造函数，使passport采用本策略 */\n    super({\n      /* token的获取方式，这里指的是从authorization请求头中获取`bearer ${token}`形式的token */\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      secretOrKey: authService.secretKey,\n      // issuer?: string;\n      // audience?: string;\n      // algorithms?: string[];\n      ignoreExpiration: false,\n      passReqToCallback: false,\n    });\n  }\n\n  /*\n  passport直接使用的是这个验证函数，这个验证函数里面调用了AuthService里的验证函数\n  这个函数被设置到JwtStrategy实例的_verify属性上\n  done方法为，通过done方法，退出JwtStrategy实例的authenticate方法\n  var verified = function (err, user, info) {\n    有错误抛出错误\n    if (err) {\n        return self.error(err);\n    } else if (!user) {\n        有效载荷不存在，抛出信息\n        return self.fail(info);\n    } else {\n        成功时，有效载荷与信息一起抛出\n        return self.success(user, info);\n    }\n};\n  */\n  async validate(payload: User, done: Function) {\n    /* 调用AuthService里的验证函数 */\n    const user = await this.authService.validateUser(payload);\n    /* 如果不存在，即返回false，则将异常传递给回调 */\n    if (!user) {\n      return done(new UnauthorizedException(), false);\n    }\n    /* 如果存在将认证后的user返回给回调 */\n    done(undefined, user);\n  }\n}\n"]}